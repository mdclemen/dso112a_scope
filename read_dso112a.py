# read_dso112a.py
# 20201226 MDC, script to read csv file generated by JYE Tech Ltd. DSO112A oscilloscope
# manaul from: https://jyetech.com/wp-content/uploads/2019/01/dso112a-user-manual.pdf
from pylab import*
import sys, argparse, scipy.signal as sig

# DSO112A serial commands
QUERY = b"\xfe\xe0\x04\x00\x00"
CONNECT = b"\xfe\xe1\x04\x00\xc0"
DISCONNECT = b"\xfe\xe9\x04\x00\x00"
GETCONFIG = b"\xfe\xc0\x04\x00\x20\x00"
GETPARAM = b"\xfe\xc0\x04\x00\x21\x00"

class dso_csv():
    def __init__(self, input_file):
        self.file_name = input_file
        fd = open(input_file, "r")
        # line 1 fields: (1) File ID, (2) Data type, (3) Date, (4) Time, (5) Device model, (6) Manufacturer
        line = fd.readline().replace("\n", "").split(",")
        self.file_id, self.data_type, self.date, self.time, self.device_model, self.manufacturer = line
        # line 2 fields: (1) Number of fields in line 3 and 4, (2) Vertical display resolution, (3) Horizontal display resolution
        line = fd.readline().replace("\n", "").split(",")
        self.n_line_34, self.vertical_display_resolution, self.horizontal_display_resolution = list(map(int, line))
        # line 3: Names of corresponding fields in line 4
        line = fd.readline().split(",")
        # line 4 fields: (1) Number of channels, (2) Record length (bytes), (3) Channel configuration, (4) Sample rate (samples/second),
        # (5) Vertical capture resolution (bits), (6) Timebase, (7) Horizontal position, (8) Trigger mode, (9) Trigger slope,
        # (10) Trigger level, (11) Trigger source, (12) Trigger position, (13) Trigger sensitivity, (14) Timebase (duplication of field 6)
        line_types = [int, int, str, float, int, int, int, int, int, int, str, int, str, int]
        line = fd.readline().replace("\n", "").split(",")
        self.n_chan, self.record_length, self.channel_config, self.sample_rate, self.vertical_capture_resolution, self.timebase,\
            self.horizontal_position, self.trigger_mode, self.trigger_slope, self.trigger_level, self.source, self.trigger_position,\
            self.trigger_sensitivity, _ = [line_types[i](k) for i, k in enumerate(line)]
        self.sample_dt = 1. / self.sample_rate
        # line 5: Vertical sensitivity
        self.vertical_sensitivity = int(fd.readline().replace("\n", "").split(",")[0])
        # line 6: Couple
        self.couple = int(fd.readline().replace("\n", "").split(",")[0])
        # line 7: Vertical position
        self.vertical_position = int(fd.readline().replace("\n", "").split(",")[0])
        # line 8: Vertical position offset
        self.vertical_position_offset = int(fd.readline().replace("\n", "").split(",")[0])
        # line 9: Resolution of voltage (volt/LSB) in unit of uV
        self.voltage_resoultion_uV = float(fd.readline().replace("\n", "").split(",")[0])
        self.voltage_resoultion = self.voltage_resoultion_uV*1e-6  # convert to volt/LSB
        # line 10: Vertical sensitivity (Duplicate of line 5)
        line = fd.readline().split(",")
        # line 11: Reference. This is the value corresponding to 0V level
        self.reference = int32(fd.readline().replace("\n", "").split(",")[0])
        fd.close()
        self.raw_data = genfromtxt(input_file, skip_header = 16, dtype = int32)  # raw data in bits
        self.raw_data_V = self.raw_data.astype(float32) * self.voltage_resoultion  # raw data in volts
        self.data = self.raw_data - self.reference  # offset removed data in bits
        self.data_V = self.data.astype(float32) * self.voltage_resoultion  # offset removed data in volts
        self.time_series = arange(0., float(self.record_length) * self.sample_dt, self.sample_dt)
        self.fft = (1. / float(self.record_length)) * fftshift(fft(self.data_V - self.data_V.mean()))  # remove any DC offset
        self.freq = fftshift(fftfreq(self.record_length, self.sample_dt))
        self.maxidx = where(abs(self.fft).max() == abs(self.fft))[0]
        # determine appropriate time/frequency scales
        self.conv_fac = {}
        if self.sample_dt < 1e-6:
            self.conv_fac = {"time_cf":1e6, "time_unit":r"$\mu s$", "freq_cf":1e-6, "freq_unit":"MHz"}
        elif (self.sample_dt < 1e-3) and (self.sample_dt >= 1e-6):
            self.conv_fac = {"time_cf":1e3, "time_unit":"ms", "freq_cf":1e-3, "freq_unit":"kHz"}
        else:
            self.conv_fac = {"time_cf":1., "time_unit":"s", "freq_cf":1., "freq_unit":"Hz"}
        self.fn = self.sample_rate * .5 # nyquist frequency
        self.data_V_lpf = None
        self.fft_lpf = None
        self.maxidx_lpf = None

    def lp_filter(self, cutoff, order = 2):
        norm_cutoff = cutoff / self.fn
        b, a = sig.butter(order, norm_cutoff, btype = "low", analog = False)
        self.data_V_lpf = sig.filtfilt(b, a, self.data_V)
        self.fft_lpf = (1. / float(self.record_length)) * fftshift(fft(self.data_V_lpf - self.data_V_lpf.mean()))  # remove any DC offset
        self.maxidx_lpf = where(abs(self.fft_lpf).max() == abs(self.fft_lpf))[0]

    def plot(self, lp_cutoff = 0.):
        fig, ax = subplots(2, 1, figsize = (10, 6))
        ax[0].plot(self.time_series * self.conv_fac["time_cf"], self.data_V, "k", lw = 2.)  # plot data with reference level subtracted
        if lp_cutoff:
            self.lp_filter(lp_cutoff)
            ax[0].plot(self.time_series * self.conv_fac["time_cf"], self.data_V_lpf, "r--", lw = 3., label = r"lpf ($f_{c/o}$=%g%s)" %
                       (lp_cutoff * self.conv_fac["freq_cf"], self.conv_fac["freq_unit"]))
            ax[0].legend(loc = "lower left", fontsize = 7, bbox_to_anchor = (.01, 1.01))
        ax[0].set_xlabel(r"time (%s)" % self.conv_fac["time_unit"], fontsize = 11)
        ax[0].set_ylabel(r"$\Phi$ (V)", fontsize = 11)
        ax[0].grid(axis = "both")
        ax[0].set_title("time domain", fontsize = 11)
        ax[1].plot(self.freq * self.conv_fac["freq_cf"], abs(self.fft), "k", lw = 2.)
        ax[1].scatter(self.freq[self.maxidx] * self.conv_fac["freq_cf"], abs(self.fft[self.maxidx]),
                      marker = "D", edgecolor = "r", s = 40, facecolor = "none")
        if lp_cutoff:
            ax[1].plot(self.freq * self.conv_fac["freq_cf"], abs(self.fft_lpf), "r--", lw = 3., label = r"lpf ($f_{c/o}$=%g%s)" %
                       (lp_cutoff * self.conv_fac["freq_cf"], self.conv_fac["freq_unit"]), alpha = .6)
            # ax[1].scatter(self.freq[self.maxidx_lpf] * self.conv_fac["freq_cf"], abs(self.fft_lpf[self.maxidx_lpf]),
            #               marker = "s", edgecolor = "m", s = 40, facecolor = "none")
            ax[1].legend(loc = "lower left", fontsize = 7, bbox_to_anchor = (.01, 1.01))
        ax[1].set_xlabel("f (%s)" % self.conv_fac["freq_unit"], fontsize = 11)
        ax[1].set_ylabel(r"$\Phi$ (V)", fontsize = 11)
        ax[1].grid(axis = "both")
        self.fmax = abs(self.freq[self.maxidx[0]]) * self.conv_fac["freq_cf"]
        max_c = abs(self.fft[self.maxidx[0]])
        ax[1].annotate(r"$f_{max}$=%.2f%s" % (self.fmax, self.conv_fac["freq_unit"]), (self.fmax, max_c),
                       xycoords = "data", xytext = (10, 0), textcoords = "offset points",
                       fontsize = 11, verticalalignment = "center")  # transform = ax[1].transAxes, arrowprops = {"arrowstyle":"wedge"},
        ax[1].set_title("frequency domain", fontsize = 11)
        fig.text(.01, .01, r"$f_{sample}$=%.1f%s | $\Delta t$=%g%s | %s" % (self.sample_rate * self.conv_fac["freq_cf"],
                                                                            self.conv_fac["freq_unit"],
                                                                            self.sample_dt * self.conv_fac["time_cf"],
                                                                            self.conv_fac["time_unit"], self.file_name),
                   fontsize = 11, transform = fig.transFigure)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description = "Plot captured signal from DSO112A.")
    parser.add_argument("--lp_cutoff", type = float, action = "store", default = 0., help = "Low pass filter cutoff frequency in Hz")
    args, unknown = parser.parse_known_args()
    try:
        infile = sys.argv[1]
    except IndexError:
        infile = input("Enter name of DSO112A text input file: ")
    data = dso_csv(infile)
    data.plot(lp_cutoff = args.lp_cutoff)
    show()
