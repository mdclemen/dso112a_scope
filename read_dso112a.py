# read_dso112a.py
# 20201226 MDC, script to read csv file generated by JYE Tech Ltd. DSO112A oscilloscope
# manaul from: https://jyetech.com/wp-content/uploads/2019/01/dso112a-user-manual.pdf
from pylab import*
import sys

class dso_csv():
    def __init__(self, input_file):
        fd = open(input_file, "r")
        # line 1 fields: (1) File ID, (2) Data type, (3) Date, (4) Time, (5) Device model, (6) Manufacturer
        line = fd.readline().replace("\n", "").split(",")
        self.file_id, self.data_type, self.date, self.time, self.device_model, self.manufacturer = line
        # line 2 fields: (1) Number of fields in line 3 and 4, (2) Vertical display resolution, (3) Horizontal display resolution
        line = fd.readline().replace("\n", "").split(",")
        self.n_line_34, self.vertical_display_resolution, self.horizontal_display_resolution = list(map(int, line))
        # line 3: Names of corresponding fields in line 4
        line = fd.readline().split(",")
        # line 4 fields: (1) Number of channels, (2) Record length (bytes), (3) Channel configuration, (4) Sample rate (samples/second),
        # (5) Vertical capture resolution (bits), (6) Timebase, (7) Horizontal position, (8) Trigger mode, (9) Trigger slope,
        # (10) Trigger level, (11) Trigger source, (12) Trigger position, (13) Trigger sensitivity, (14) Timebase (duplication of field 6)
        line_types = [int, int, str, float, int, int, int, int, int, int, str, int, str, int]
        line = fd.readline().replace("\n", "").split(",")
        self.n_chan, self.record_length, self.channel_config, self.sample_rate, self.vertical_capture_resolution, self.timebase,\
            self.horizontal_position, self.trigger_mode, self.trigger_slope, self.trigger_level, self.source, self.trigger_position,\
            self.trigger_sensitivity, _ = [line_types[i](k) for i, k in enumerate(line)]
        self.sample_dt = 1. / self.sample_rate
        # line 5: Vertical sensitivity
        self.vertical_sensitivity = int(fd.readline().replace("\n", "").split(",")[0])
        # line 6: Couple
        self.couple = int(fd.readline().replace("\n", "").split(",")[0])
        # line 7: Vertical position
        self.vertical_position = int(fd.readline().replace("\n", "").split(",")[0])
        # line 8: Vertical position offset
        self.vertical_position_offset = int(fd.readline().replace("\n", "").split(",")[0])
        # line 9: Resolution of voltage (volt/LSB) in unit of uV
        self.voltage_resoultion_uV = float(fd.readline().replace("\n", "").split(",")[0])
        self.voltage_resoultion = self.voltage_resoultion_uV*1e-6  # convert to volt/LSB
        # line 10: Vertical sensitivity (Duplicate of line 5)
        line = fd.readline().split(",")
        # line 11: Reference. This is the value corresponding to 0V level
        self.reference = int32(fd.readline().replace("\n", "").split(",")[0])
        fd.close()
        self.raw_data = genfromtxt(input_file, skip_header = 16, dtype = int32)  # raw data in bits
        self.raw_data_V = self.raw_data.astype(float32) * self.voltage_resoultion  # raw data in volts
        self.data = self.raw_data - self.reference  # offset removed data in bits
        self.data_V = self.data.astype(float32) * self.voltage_resoultion  # offset removed data in volts
        self.time_series = arange(0., float(self.record_length) * self.sample_dt, self.sample_dt)
        self.fft = (1. / float(self.record_length)) * fftshift(fft(self.data_V - self.data_V.mean()))  # remove any DC offset
        self.freq = fftshift(fftfreq(self.record_length, self.sample_dt))
        self.maxidx = where(abs(self.fft).max() == abs(self.fft))[0]
        # determine appropriate time/frequency scales
        self.conv_fac = {}
        if self.sample_dt <= 1e-4:
            self.conv_fac = {"time_cf":1e6, "time_unit":r"$\mu s$", "freq_cf":1e-6, "freq_unit":"MHz"}
        elif (self.sample_dt <= 1e-1) and (self.sample_dt > 1e-4):
            self.conv_fac = {"time_cf":1e3, "time_unit":"ms", "freq_cf":1e-3, "freq_unit":"kHz"}
        else:
            self.conv_fac = {"time_cf":1., "time_unit":"s", "freq_cf":1., "freq_unit":"Hz"}

    def plot(self):
        fig, ax = subplots(2, 1, figsize = (10, 6))
        ax[0].plot(self.time_series * self.conv_fac["time_cf"], self.data_V, "k", lw = 2.)  # plot data with reference level subtracted
        ax[0].set_xlabel(r"time (%s)" % self.conv_fac["time_unit"], fontsize = 11)
        ax[0].set_ylabel(r"$\Phi$ (V)", fontsize = 11)
        ax[0].grid(axis = "both")
        ax[0].set_title("time domain", fontsize = 11)
        ax[1].plot(self.freq * self.conv_fac["freq_cf"], abs(self.fft), "k", lw = 2.)
        ax[1].scatter(self.freq[self.maxidx] * self.conv_fac["freq_cf"], abs(self.fft[self.maxidx]),
                      marker = "D", edgecolor = "r", s = 40, facecolor = "none")
        ax[1].set_xlabel("f (%s)" % self.conv_fac["freq_unit"], fontsize = 11)
        ax[1].set_ylabel(r"$\Phi$ (V)", fontsize = 11)
        ax[1].grid(axis = "both")
        max_f = abs(self.freq[self.maxidx[0]]) * self.conv_fac["freq_cf"]
        max_c = abs(self.fft[self.maxidx[0]])
        ax[1].annotate(r"$f_{max}$=%.2f%s" % (max_f, self.conv_fac["freq_unit"]), (max_f, max_c),
                       xycoords = "data", xytext = (10, 0), textcoords = "offset points",
                       fontsize = 11, verticalalignment = "center")  # transform = ax[1].transAxes, arrowprops = {"arrowstyle":"wedge"},
        ax[1].set_title("frequency domain", fontsize = 11)

if __name__ == "__main__":
    try:
        infile = sys.argv[1]
    except IndexError:
        infile = input("Enter name of DSO112A text input file: ")
    data = dso_csv(infile)
    data.plot()
    show()
